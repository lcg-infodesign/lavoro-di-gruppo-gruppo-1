// Defined Cluster Simulation with Strong Group Characteristics

const CLUSTER_CONFIGURATION = {
  canvasSize: {
    width: 800,
    height: 800
  },
  clusters: [
    {
      center: { x: 250, y: 250 },
      color: [70, 130, 210],    // Soft Blue
      radius: 100,              // Cluster containment radius
      agentCount: 29,           // Fixed agent count of 29
      attractionStrength: 0.3,  // Force pulling agents to cluster center
      boundaryStiffness: 0.5    // Strength of boundary enforcement
    },
    {
      center: { x: 550, y: 550 },
      color: [220, 80, 120],    // Coral Pink
      radius: 120,              // Slightly larger cluster area
      agentCount: 29,           // Fixed agent count of 29
      attractionStrength: 0.4,
      boundaryStiffness: 0.6
    },
    
        {
      center: { x: 25, y: 150 },
      color: [70, 10, 210],    // Soft Blue
      radius: 100,              // Cluster containment radius
      agentCount: 29,           // Fixed agent count of 29
      attractionStrength: 0.3,  // Force pulling agents to cluster center
      boundaryStiffness: 0.5    // Strength of boundary enforcement
    },
        {
      center: { x: 230, y: 600 },
      color: [70, 130, 210],    // Soft Blue
      radius: 170,              // Cluster containment radius
      agentCount: 29,           // Fixed agent count of 29
      attractionStrength: 0.3,  // Force pulling agents to cluster center
      boundaryStiffness: 0.5    // Strength of boundary enforcement
    },
        {
      center: { x: 550, y: 350 },
      color: [70, 130, 210],    // Soft Blue
      radius: 100,              // Cluster containment radius
      agentCount: 29,           // Fixed agent count of 29
      attractionStrength: 0.3,  // Force pulling agents to cluster center
      boundaryStiffness: 0.5    // Strength of boundary enforcement
    },
  ]
};




class ClusterAgent {
  constructor(x, y, cluster) {
    // Position management
    this.homeCluster = cluster;
    this.position = createVector(x, y);
    this.velocity = createVector(0, 0);
    this.acceleration = createVector(0, 0);

    // Movement constraints
    this.maxSpeed = 2;
    this.maxForce = 0.1;
    this.radius = 8;  // Random radius for variation

    // Color management
    this.baseColor = cluster.color;
    this.currentColor = [...this.baseColor];

    // Friction coefficient
    this.friction = 0.2; // Less than 1 for gradual slowdown, 1 means no friction
  }

  // Advanced cluster-based force calculation
  applyClusterBehaviors(agents) {
    let clusterCenterAttraction = this.attractToClusterCenter();
    let separationForce = this.calculateSeparation(agents);
    let boundaryConstraint = this.enforceClusterBoundary();

    // Weighted force application
    clusterCenterAttraction.mult(this.homeCluster.attractionStrength);
    separationForce.mult(1);
    boundaryConstraint.mult(this.homeCluster.boundaryStiffness);

    // Accumulate forces
    this.acceleration.add(clusterCenterAttraction);
    this.acceleration.add(separationForce);
    this.acceleration.add(boundaryConstraint);
  }

  // Strong attraction to cluster center
  attractToClusterCenter() {
    let clusterCenter = createVector(this.homeCluster.center.x, this.homeCluster.center.y);
    let desired = p5.Vector.sub(clusterCenter, this.position);
    desired.normalize();
    desired.mult(this.maxSpeed);

    let steer = p5.Vector.sub(desired, this.velocity);
    steer.limit(this.maxForce * 2);  // Stronger attraction force
    return steer;
  }

  // Sophisticated separation mechanism
  calculateSeparation(agents) {
    let desiredSeparation = this.radius * 2.5;
    let steer = createVector(0, 0);
    let count = 0;

    for (let other of agents) {
      // Only separate from agents in the same cluster
      if (other.homeCluster === this.homeCluster) {
        let distance = p5.Vector.dist(this.position, other.position);
        
        if (distance > 0 && distance < desiredSeparation) {
          let diff = p5.Vector.sub(this.position, other.position);
          diff.normalize();
          diff.div(distance);  // Force inversely proportional to distance
          steer.add(diff);
          count++;
        }
      }
    }

    if (count > 0) {
      steer.div(count);
      steer.normalize();
      steer.mult(this.maxSpeed);
      steer.sub(this.velocity);
      steer.limit(this.maxForce * 2);  // Greater separation force
    }

    return steer;
  }

  // Strong boundary enforcement
  enforceClusterBoundary() {
    let clusterCenter = createVector(this.homeCluster.center.x, this.homeCluster.center.y);
    let distanceFromCenter = p5.Vector.dist(this.position, clusterCenter);
    let clusterRadius = this.homeCluster.radius;

    // If agent is outside cluster radius, apply strong return force
    if (distanceFromCenter > clusterRadius) {
      let returnForce = p5.Vector.sub(clusterCenter, this.position);
      returnForce.normalize();
      returnForce.mult((distanceFromCenter - clusterRadius) * 0.5);
      return returnForce;
    }

    return createVector(0, 0);
  }

  // Update and rendering methods
  update() {
    // Apply friction: slow down the velocity over time
    this.velocity.mult(this.friction);

    // Apply acceleration to velocity
    this.velocity.add(this.acceleration);
    this.velocity.limit(this.maxSpeed);
    this.position.add(this.velocity);

    // Reset acceleration
    this.acceleration.mult(0);
  }

  display() {
    noStroke();
    // Slight color variation within cluster
    fill("white");
    ellipse(this.position.x, this.position.y, this.radius * 2);
  }
}

let agents = [];

function setup() {
  createCanvas(CLUSTER_CONFIGURATION.canvasSize.width, CLUSTER_CONFIGURATION.canvasSize.height);

  // Generate agents for each cluster
  CLUSTER_CONFIGURATION.clusters.forEach(cluster => {
    for (let i = 0; i < cluster.agentCount; i++) {
      let placed = false;
      let attempts = 0;

      while (!placed && attempts < 100) {
        let angle = random(TWO_PI);
        let radius = random(0, cluster.radius * 0.8);
        
        let x = cluster.center.x + cos(angle) * radius;
        let y = cluster.center.y + sin(angle) * radius;
        
        // Check for overlap with existing agents
        let overlaps = agents.some(agent => 
          p5.Vector.dist(createVector(x, y), agent.position) < agent.radius * 2
        );
        
        if (!overlaps) {
          agents.push(new ClusterAgent(x, y, cluster));
          placed = true;
        }
        
        attempts++;
      }

      if (!placed) {
        console.warn(`Could not place agent in cluster at (${cluster.center.x}, ${cluster.center.y})`);
      }
    }
  });
}

function draw() {
  // Atmospheric background
  background(20, 20, 40);

  // Optional: Visualize cluster boundaries
  noFill();
  CLUSTER_CONFIGURATION.clusters.forEach(cluster => {
    stroke(cluster.color[0], cluster.color[1], cluster.color[2], 50);
    ellipse(cluster.center.x, cluster.center.y, cluster.radius * 2);
  });

  // Simulation loop
  for (let agent of agents) {
    agent.applyClusterBehaviors(agents);
    agent.update();
    agent.display();
  }
}



// Funzione per creare un cluster
function createCluster(centerX, centerY, color, radius, attractionStrength, boundaryStiffness, agentCount) {
  return {
    center: { x: centerX, y: centerY },
    color: color,
    radius: radius,
    agentCount: agentCount,
    attractionStrength: attractionStrength,
    boundaryStiffness: boundaryStiffness
  };
}

// Funzione per popolare l'array dei cluster
function generateClusters() {
  const clusters = [];

  // Definire i cluster desiderati
  clusters.push(createCluster(250, 250, [70, 130, 210], 100, 0.3, 0.5, 29));
  clusters.push(createCluster(550, 550, [220, 80, 120], 120, 0.4, 0.6, 29));
  clusters.push(createCluster(25, 150, [70, 10, 210], 100, 0.3, 0.5, 29));
  clusters.push(createCluster(230, 600, [70, 130, 210], 170, 0.3, 0.5, 29));
  clusters.push(createCluster(550, 350, [70, 130, 210], 100, 0.3, 0.5, 29));

  // Aggiungere altri cluster casuali, se necessario
  // Per esempio, puoi aggiungere 5 cluster casuali:
  for (let i = 0; i < 5; i++) {
    clusters.push(createCluster(
      random(100, 700),    // X posizione casuale
      random(100, 700),    // Y posizione casuale
      [random(100, 255), random(100, 255), random(100, 255)],  // Colore casuale
      random(40, 120),     // Raggio casuale
      random(0.2, 0.5),    // Forza di attrazione casuale
      random(0.3, 0.7),    // RigiditÃ  del confine casuale
      29                   // Numero fisso di agenti
    ));
  }

  return clusters;
}
